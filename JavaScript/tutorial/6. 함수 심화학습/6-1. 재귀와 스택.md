# 6. 함수 심화학습
## 6-1. 재귀와 스택
### 재귀
함수 내부에서 자기 자신을 호출하는 것  
재귀를 사용한 코드는 반복적 사고에 근거하여 작성한 코드보다 짧음
```javascript
// x를 n 제곱해 주는 함수 pow(x, n) 예시

function pow(x, n) {
    if (n == 1) {
        return x;
    } else {
        return x * pow(x, n - 1);
    }
}

alert(pow(2, 3)); // 8
```
1. `n == 1`일 때  

    **명확한 결괏값을 즉시 도출**하므로 <U>재귀의 베이스</U>라고 함 (`pow(x, 1) = x`)
2. `n == 1`이 아닐 때  

    `pow(x, n)`은 `x * pow(x, n-1)`으로 표현할 수 있음 (수학식으론 `x^n = x * x^n-1`)  
    이 과정을 <U>재귀 단계</U>라고 하며, 예시에서 재귀 단계는 n이 1이 될 때까지 계속됨  


#### ▶ 재귀 단계 순서 (`pow(2, 4)` 예시)
1. pow(2, 4) = 2 * pow(2, 3)
2. pow(2, 3) = 2 * pow(2, 2)
3. pow(2, 2) = 2 * pow(2, 1)
4. pow(2, 1) = 2

#### ▶ 재귀 깊이(recursion depth)
재귀 함수에서 가장 처음 하는 호출을 포함한 중첩 호출의 최대 개수 (`pow(x, n)`에서 재귀 깊이는 `n`)  

자바스크립트 엔진은 최대 재귀 깊이를 제한하는데, 만 개까지는 확실히 허용하고 그 이상의 경우 엔진 내부에서 자동으로 `tail calls optimization`을 통해 최적화를 수행함 (간단한 경우)
### 실행 컨텍스트와 스택
함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조  
#### ▶ 함수 내부 중첩 호출 실행 절차
1. 현재 함수의 실행이 일시 중지됨
2. 중지된 함수와 연관된 `실행 컨텍스트`는 `실행 컨텍스트 스택`이라는 자료 구조에 저장됨
3. 중첩 호출이 실행됨
4. 중첩 호출 실행이 끝난 후 `실행 컨텍스트 스택`에서 일시 중단한 함수의 `실행 컨텍스트`를 꺼내오고, 중단한 함수의 실행을 이어감
### 재귀적 구조
자기 자신의 일부를 복제하는 형태의 자료 구조
#### ▶ 연결 리스트
배열은 `arr.push/pop`을 제외하고, 배열의 요소를 삽입/삭제하려면 요소 전체의 번호를 다시 매겨야 함  
이 과정이 비효율적이기 때문에 요소를 빠르게 삽입/삭제하려면 배열 대신 `연결 리스트`를 사용하는 것이 좋음
```javascript
let list = {
    value: 1,
    next: {
        value: 2,
        next: {
            value: 3,
            next: {
                value: 4,
                next: null
            }
        }
    }
};

// 위와 동일하게 작동하는 코드
let list = {value: 1};
list.next = {value: 2};
list.next.next = {value: 3};
list.next.next.next = {value: 4};
list.next.next.next.next = null;
```
